## Set (множество) — неупорядоченная коллекция уникальных элементов

Set представляет собой тип данных для хранения неупорядоченной коллекции уникальных элементов. Используется вместо массива, когда нужно эффективно проверять принадлежность элемента коллекции и не важен порядок элементов, либо когда требуется гарантировать уникальность каждого элемента.

### Основные характеристики

**Требования к элементам:** Set может содержать любые элементы, соответствующие протоколу Hashable. По умолчанию большинство типов стандартной библиотеки являются хэшируемыми: строки, числовые и булевые типы, значения перечислений без ассоциированных значений, а также сами множества.

**Создание:** Множество создается простым присваиванием массива литералов переменной или константе с указанным типом Set :
```swift
let ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
```

### Основные операции

**Проверка принадлежности:** Метод `contains()` проверяет наличие конкретного элемента в множестве.

**Операции сравнения множеств:**
- `isSubset(of:)` — проверяет, является ли множество подмножеством другого
- `isSuperset(of:)` — проверяет, является ли множество надмножеством другого
- `isStrictSubset(of:)` и `isStrictSuperset(of:)` — строгие подмножество и надмножество
- `isDisjoint(with:)` — проверяет отсутствие общих элементов

### Математические операции над множествами

**Объединяющие операции:**
- `union()` — создает новое множество из элементов двух множеств
- `intersection()` — создает множество только из общих элементов
- `symmetricDifference()` — элементы, присутствующие в одном из множеств, но не в обоих
- `subtracting()` — элементы первого множества, отсутствующие во втором

**Модифицирующие операции:** Методы `formUnion()`, `formIntersection()`, `formSymmetricDifference()` и `subtract()` изменяют исходное множество.

### Методы работы с коллекцией

**Добавление и удаление:**
- `insert()` — добавляет элемент, возвращает кортеж с результатом операции
- `update(with:)` — безусловно вставляет элемент, заменяя существующий
- `remove()` — удаляет элемент по значению
- `removeFirst()` — удаляет первый элемент

**Итерация:** Можно итерироваться через неупорядоченные элементы множества с помощью цикла for-in. Многие операции последовательности и коллекций возвращают массив или обобщенную обертку коллекции, поэтому для восстановления эффективных операций множества нужно создавать новый Set из результата.


## Ключевые ограничения типа Set

### Требования к элементам
- Элементы должны быть хэшируемыми: тип элемента обязан соответствовать протоколу Hashable; без корректного хэширования множество не может обеспечивать уникальность и быстрый доступ.
- Равные объекты должны иметь равные хеши.

### Структурные свойства коллекции
- Неупорядоченность: Set не гарантирует стабильного порядка итерации; «первый» элемент не связан со временем добавления.
- Уникальность: дубликаты запрещены; попытка вставить равный элемент не изменяет состав множества, а update(with:) заменяет существующий.
- Многие операции последовательностей возвращают не Set: после map/filter/sorted результат часто массив/обёртка; для восстановления семантики множества требуется явная инициализация Set из результата.

### Операции и их ограничения
- Сравнение множеств: isSubset(of:), isSuperset(of:), строгие варианты и isDisjoint(with:) требуют конечных последовательностей; «строгость» исключает равенство множеств.
- Математические операции: union, intersection, subtracting, symmetricDifference создают новые множества; для изменения на месте нужны formUnion/formIntersection/formSymmetricDifference/subtract.
- Индексация не предназначена для позиционной логики: индексы непрозрачны и завязаны на внутреннее размещение, поэтому нельзя полагаться на «позиции» элементов, как в массиве.
- Итерация и popFirst/removeFirst не гарантируют определенного порядка извлечения; использовать их для очереди/стека некорректно.

